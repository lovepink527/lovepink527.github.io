<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="一、vite初始化项目       12345678# 创建vite项目，选择vue -&gt; 选择vue-ts npm init @vitejs&#x2F;app myProject# 进入项目 cd myProject# 安装依赖 npm install# 启动项目 npm run dev">
<meta property="og:type" content="article">
<meta property="og:title" content="vue3初体验">
<meta property="og:url" content="https://lovepink527.github.io/2022/01/11/vue3%E5%88%9D%E4%BD%93%E9%AA%8C/index.html">
<meta property="og:site_name" content="lovepink">
<meta property="og:description" content="一、vite初始化项目       12345678# 创建vite项目，选择vue -&gt; 选择vue-ts npm init @vitejs&#x2F;app myProject# 进入项目 cd myProject# 安装依赖 npm install# 启动项目 npm run dev">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-11T10:40:23.000Z">
<meta property="article:modified_time" content="2022-01-16T01:54:47.498Z">
<meta property="article:author" content="姜慧慧">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary"><title>vue3初体验 | lovepink</title><link ref="canonical" href="https://lovepink527.github.io/2022/01/11/vue3%E5%88%9D%E4%BD%93%E9%AA%8C/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="lovepink" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-about"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">lovepink</div><div class="header-banner-info__subtitle">热爱可抵岁月漫长</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">vue3初体验</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-01-11</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-01-16</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h3 id="一、vite初始化项目"   >
          <a href="#一、vite初始化项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、vite初始化项目" class="headerlink" title="一、vite初始化项目"></a>一、vite初始化项目</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建vite项目，选择vue -&gt; 选择vue-ts</span></span><br><span class="line"> npm init @vitejs/app myProject</span><br><span class="line"><span class="comment"># 进入项目</span></span><br><span class="line"> <span class="built_in">cd</span> myProject</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"> npm install</span><br><span class="line"><span class="comment"># 启动项目</span></span><br><span class="line"> npm run dev</span><br></pre></td></tr></table></div></figure>
<span id="more"></span> 

        <h3 id="二、Composition-API-常用部分"   >
          <a href="#二、Composition-API-常用部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Composition-API-常用部分" class="headerlink" title="二、Composition API(常用部分)"></a>二、Composition API(常用部分)</h3>
      
        <h4 id="2-1setup和ref"   >
          <a href="#2-1setup和ref" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1setup和ref" class="headerlink" title="2.1setup和ref"></a>2.1setup和ref</h4>
      <ul>
<li>setup是组合api中第一个要使用的函数</li>
<li>setup是组合api的入口函数</li>
<li>ref对象是一个函数，作用是定义一个响应式数据,返回一个ref对象，对象中有一个value属性，如果需要对修改，可以修改value</li>
<li>ref可以获取页面中的元素const inputRef = ref&lt;HTMLElement | null&gt;(null)</li>
<li>html是不需要用count.value取数据的，直接count就可以<figure class="highlight typescript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//变量</span></span><br><span class="line">	<span class="comment">//const number = 10 // 此时还不是相应数据</span></span><br><span class="line">	<span class="keyword">const</span> count = ref(<span class="number">0</span>) <span class="comment">// ref对象是一个函数，作用是定义一个响应式数据,返回一个ref对象，对象中有一个value属性，如果需要对修改，可以修改value</span></span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">updateCount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		count.value ++ </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回一个对象</span></span><br><span class="line">	<span class="comment">//把变量和方法都暴露出去</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		count,</span><br><span class="line">		updateCount</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>setup执行的时机</strong></p>
<ul>
<li>setup是beforeCreate声明周期回调之前就执行了，而且执行一次</li>
<li>由此可以推断出，在setup执行的时候，当前的组件还没有创建，也就意味着：组件实例对象this根本就不能使用</li>
<li>this是undefined,说明，就不能通过this再去调用data/computed/methods/props中的相关内容了</li>
<li>其实所有的composition API相关回调函数中也都不可以</li>
</ul>
<p><strong>setup返回值</strong></p>
<ul>
<li>setup中的返回值是一个对象，内部的属性和方法是给html模板使用</li>
<li>setup中的对象内部的属性和data函数中的return对象的属性都可以在html模板中使用</li>
<li>setup中的对象中的属性和data函数中的对象中的属性会合并为组件对象的属性</li>
<li>setup中的对象中的方法和methods对象中的方法会合并为组件的方法</li>
<li>在vue3中尽量不要混合使用data\setup\method\setup</li>
<li>setup不能是一个async函数：因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性数据</li>
</ul>
<p><strong>setup中的参数</strong></p>
<figure class="highlight typescript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line"><span class="comment">// props参数，是一个对象，里面有父级组件向子集组件传递的数据，并且在子集组件中使用prop接收到的所有的属性</span></span><br><span class="line"><span class="comment">// 包含props配置声明且传入了的所有属性的对象</span></span><br><span class="line"><span class="comment">// context参数，是一个对象，里面有attar对象（获取当前组件标签上的所有的属性的对象，但是该属性是在props中没有声明接收的所有的需要的对象），emit方法（分发事件），slots对象（插槽）</span></span><br><span class="line"><span class="comment">// 包含没有在props配置中声明的属性的对象，相当于this.$attrs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2-2reactive的使用"   >
          <a href="#2-2reactive的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2reactive的使用" class="headerlink" title="2.2reactive的使用"></a>2.2reactive的使用</h4>
      <ul>
<li>作用：定义一个响应式复杂数据</li>
<li>使用proxy实现，通过代理对象操作源对象内部数据都是响应式的</li>
<li>const proxy = reactive(obj): 接口一个普通对象然后返回该普通对象的响应式代理器对象。</li>
<li>响应式转换是‘深层的’：会影响对象内部所有嵌套的属性</li>
<li><figure class="highlight typescript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 把复杂数据变成响应式数据</span></span><br><span class="line"><span class="comment">// 返回的是一个Proxy的代理对象，被代理者的对象就是obj对象</span></span><br><span class="line"><span class="comment">// user现在式代理对象，obj式目标对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">	<span class="attr">wife</span>:&#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">const</span> user = reactive(obj)</span><br><span class="line">	<span class="comment">// 方法</span></span><br><span class="line">	<span class="keyword">const</span> updateUser = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 直接使用目标对象的方式来更新目标对象中的成员值，式不可能的，只能使用代理对象更新目标对象</span></span><br><span class="line">		user.name = <span class="string">&#x27;小小&#x27;</span></span><br><span class="line">		obj.gender = <span class="string">&#x27;男&#x27;</span> <span class="comment">//界面不会更新</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		user,</span><br><span class="line">		updateUser</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user对象或者obj对象添加一个新的属性，删除一个新的属性</span></span><br><span class="line"><span class="comment">//  === 添加</span></span><br><span class="line"><span class="comment">// 对obj操作界面没有变化，对user操作界面会变化,obj确实变化啦</span></span><br><span class="line"><span class="comment">// 对user操作，obj也会会更新值，界面变化</span></span><br></pre></td></tr></table></div></figure>
细节：
        <h4 id="2-3vue2和vue3的响应式"   >
          <a href="#2-3vue2和vue3的响应式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3vue2和vue3的响应式" class="headerlink" title="2.3vue2和vue3的响应式"></a>2.3vue2和vue3的响应式</h4>
      </li>
</ul>
<p><strong>vue2的响应式</strong><br><strong>核心：</strong></p>
<ul>
<li>对象：通过defineProperty对对象的已有的读取和修改进行拦截（监听和拦截）</li>
<li>数据：通过重写数组更新数组一些列更新元素的方式来实现元素修改的劫持</li>
</ul>
<figure class="highlight typescript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data,<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p><strong>问题：</strong></p>
<ul>
<li>对象直接新添加的属性或者删除已有属性，界面不会自动更新</li>
<li>直接通过下标替换元素或者更新length,界面不会自动更新arr[1] = {}</li>
<li>所有有了后来的$set()方法实现响应式</li>
</ul>
<hr>
<p> <strong>vue3的响应式</strong><br><strong>核心：</strong></p>
<ul>
<li>通过Proxy(代理)：拦截对data任意属性的操作，包括属性值的读写，属性的添加、属性的删除等</li>
<li>通过Reflect(反射)：动态对被代理对象的相应属性进行特定的操作</li>
</ul>
<figure class="highlight typescript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span><br><span class="line"><span class="comment">//拦截获取属性值</span></span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">target,prop</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,prop)</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="comment">//拦截设置属性值</span></span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">target,prop,value</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,prop,value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-4ref和reactive"   >
          <a href="#2-4ref和reactive" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4ref和reactive" class="headerlink" title="2.4ref和reactive"></a>2.4ref和reactive</h4>
      <ul>
<li>重要的响应式API(ref和reactive)</li>
<li>ref用来处理基本类型数据，react用来处理对象（递归深度响应式）</li>
<li>如果ref对象/数组，内部会自动将对象/数组转换为reactive的代理对象</li>
<li>ref内部：通过给value属性添加getter/setter来实现对数据的劫持</li>
<li>reactive内部：通过proxy来实现对对象内部所有数据的劫持，并通过Reflect来更新源目标对象</li>
<li>ref的数据操作，在js中要.value,在模板中不需要（内部自动解析）
        <h4 id="2-5计算属性和监视"   >
          <a href="#2-5计算属性和监视" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5计算属性和监视" class="headerlink" title="2.5计算属性和监视"></a>2.5计算属性和监视</h4>
      </li>
</ul>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="attr">firstName</span>:<span class="string">&#x27;东方&#x27;</span>,</span><br><span class="line">	<span class="attr">lastName</span>:<span class="string">&#x27;不败&#x27;</span></span><br><span class="line">	<span class="keyword">const</span> fullName = computed(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> user.firstName + <span class="string">&#x27;_&#x27;</span> + user.lastName</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> fulName3 = ref(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">	<span class="comment">//监视指定数据</span></span><br><span class="line">	watch(user,<span class="function">(<span class="params">firstName,lastName</span>)=&gt;</span>&#123;</span><br><span class="line">		fullName3.value = firstName + <span class="string">&#x27;_&#x27;</span> + lastName</span><br><span class="line">	&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line">	<span class="comment">// immediate默认执行一次，deep深度监视</span></span><br><span class="line">	<span class="comment">//监视，不需要配置immediate，本身默认就会进行监视，默认执行一次</span></span><br><span class="line">	watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">		fullName3.value = user.firstName + <span class="string">&#x27;_&#x27;</span> + user.lastName</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// watch可以监视多个数据,如果不是响应式数据需要回调的方式</span></span><br><span class="line">	watch([<span class="function">()=&gt;</span>firstName,<span class="function">()=&gt;</span>lastName,<span class="function">()=&gt;</span>fullName3],<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		user,</span><br><span class="line">		fullName,</span><br><span class="line">		fullName3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-6声明周期对比"   >
          <a href="#2-6声明周期对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6声明周期对比" class="headerlink" title="2.6声明周期对比"></a>2.6声明周期对比</h4>
      
        <h5 id="2-6-1与2-0的声明周期对应的组合API"   >
          <a href="#2-6-1与2-0的声明周期对应的组合API" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-1与2-0的声明周期对应的组合API" class="headerlink" title="2.6.1与2.0的声明周期对应的组合API"></a>2.6.1与2.0的声明周期对应的组合API</h5>
      <ul>
<li>beforeCreate -&gt; setup()</li>
<li>created -&gt; setup()</li>
<li>beforeMount -&gt; onBeforeMount</li>
<li>mounted -&gt; onMounted</li>
<li>beforeUpdate -&gt; onBeforeUpdate</li>
<li>updated -&gt; onupdated</li>
<li>beforeDestroy改名啦 -&gt; onBeforeUnmount</li>
<li>destroyed改名啦 -&gt; onUnmounted</li>
<li>errCaptured -&gt; onErrorCaptured
        <h5 id="2-6-2-新增钩子函数"   >
          <a href="#2-6-2-新增钩子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-2-新增钩子函数" class="headerlink" title="2.6.2 新增钩子函数"></a>2.6.2 新增钩子函数</h5>
      </li>
<li>onRenderTracked</li>
<li>onRenderTriggred</li>
<li>两个钩子函数都接收一个DebuggerEvent,与watchEffect参数选项中的onTrack和onTrigger类似</li>
</ul>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-7hook函数自定义"   >
          <a href="#2-7hook函数自定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7hook函数自定义" class="headerlink" title="2.7hook函数自定义"></a>2.7hook函数自定义</h4>
      <ul>
<li>类似于axios封装
        <h4 id="2-8toRefs"   >
          <a href="#2-8toRefs" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-8toRefs" class="headerlink" title="2.8toRefs"></a>2.8toRefs</h4>
      </li>
<li>把一个响应式对象转换成普通对象，该普通对象的每个property都有一个ref</li>
<li>应用： 当从合成函数返回响应式对象时，toRefs非常有用，这样消费组件就可以在不丢失响应式的情况下，返回对象进行分解使用</li>
</ul>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">		<span class="attr">name</span>: <span class="string">&#x27;自来也&#x27;</span>,</span><br><span class="line">		<span class="attr">age</span>: <span class="number">47</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">const</span> &#123;name,age&#125; = toRefs(state)</span><br><span class="line">	<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">		name.name += <span class="string">&#x27;==&#x27;</span></span><br><span class="line">	&#125;,<span class="number">2000</span>)</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		...state, <span class="comment">// 不是响应式的数据</span></span><br><span class="line">		name,</span><br><span class="line">		age</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="三、Composition-API-其他部分"   >
          <a href="#三、Composition-API-其他部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Composition-API-其他部分" class="headerlink" title="三、Composition API(其他部分)"></a>三、Composition API(其他部分)</h3>
      
        <h4 id="3-1-shallowReactive-与-shallowRef"   >
          <a href="#3-1-shallowReactive-与-shallowRef" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-shallowReactive-与-shallowRef" class="headerlink" title="3.1 shallowReactive 与 shallowRef"></a>3.1 shallowReactive 与 shallowRef</h4>
      <ul>
<li>shallowReactive 浅劫持：只处理了对象内最外层属性的响应式</li>
<li>shallowRef  浅劫持： 只处理了value的响应式，不进行对象的reactive处理</li>
<li>如果一个对象数据，结构比较深，但变化时只是外层属性变化 shallowReactive</li>
<li>如果一个对象数据，后面会产生新的对象来替换 shallowRef
        <h4 id="3-1-readonly和shallowReadonly"   >
          <a href="#3-1-readonly和shallowReadonly" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-readonly和shallowReadonly" class="headerlink" title="3.1 readonly和shallowReadonly"></a>3.1 readonly和shallowReadonly</h4>
      </li>
<li>readonly 深度只读</li>
<li>shallowReadonly 浅只读的
        <h4 id="3-2-toRaw和markRaw"   >
          <a href="#3-2-toRaw和markRaw" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-toRaw和markRaw" class="headerlink" title="3.2 toRaw和markRaw"></a>3.2 toRaw和markRaw</h4>
      </li>
<li>toRaw 把代理对象变成普通对象，数据变化，界面不变化</li>
<li>markRaw 标记的对象数据，从此以后再也不能成为代理对象啦
        <h4 id="3-3-toRef和ref"   >
          <a href="#3-3-toRef和ref" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-toRef和ref" class="headerlink" title="3.3 toRef和ref"></a>3.3 toRef和ref</h4>
      </li>
<li>ref—-&gt;复制，修改响应式数据不会影响原始数据</li>
<li>toref—-&gt;引用，修改响应式数据，会影响原始数据</li>
<li>ref——&gt;数据发生改变，界面就会自动更新</li>
<li>toref—–&gt; 数据发生改变，界面也不会更新</li>
<li>torefs是影响多个参数
        <h4 id="3-4-customRef"   >
          <a href="#3-4-customRef" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-customRef" class="headerlink" title="3.4 customRef"></a>3.4 customRef</h4>
      (1) customRef 用于自定义返回一个ref对象,可以显式地控制依赖追踪和触发响应,接受工厂函数<br>(2) 两个参数分别是用于追踪的 track 与用于触发响应的 trigger，并返回一个一个带有 get 和 set 属性的对象</li>
</ul>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDebouncedRef</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	      <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">	        <span class="keyword">return</span> &#123;</span><br><span class="line">	          <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	            track()	追踪当前数据</span><br><span class="line">	            <span class="keyword">return</span> value</span><br><span class="line">	          &#125;,</span><br><span class="line">	          <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">	            value=newValue</span><br><span class="line">	            trigger() 触发响应,即更新界面</span><br><span class="line">	          &#125;,</span><br><span class="line">	        &#125;</span><br><span class="line">	      &#125;)</span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">通过customRef返回的ref对象,和正常ref对象一样,通过x.value修改或读取值</span><br></pre></td></tr></table></div></figure>

        <h4 id="3-5-provide和inject"   >
          <a href="#3-5-provide和inject" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-5-provide和inject" class="headerlink" title="3.5 provide和inject"></a>3.5 provide和inject</h4>
      <ul>
<li>作用：用于父组件向子孙组件传递数据</li>
<li>使用方法：provide在父组件中返回要传给下级的数据，inject在需要使用这个数据的子辈组件或者孙辈等下级组件中注入数据。</li>
<li>使用场景：由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现跨级访问父组件的数据
        <h4 id="3-6-响应式判断"   >
          <a href="#3-6-响应式判断" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-6-响应式判断" class="headerlink" title="3.6 响应式判断"></a>3.6 响应式判断</h4>
      </li>
<li>isRef:检查一个值是否为一个ref对象</li>
<li>isReactive:检查一个值是否为一个reactive创建的响应式对象</li>
<li>isReadonly:检查一个值是否为一个readonly创建的只读代理</li>
<li>isProxy:检查一个值是否为一个reactive或者readonly方法创建的代理
        <h3 id="四、Composition-API-新"   >
          <a href="#四、Composition-API-新" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Composition-API-新" class="headerlink" title="四、Composition API(新)"></a>四、Composition API(新)</h3>
      
        <h4 id="4-1-Fragment"   >
          <a href="#4-1-Fragment" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-Fragment" class="headerlink" title="4.1 Fragment"></a>4.1 Fragment</h4>
      </li>
<li>vue2中<template>必须有一个根组件，vue3不需要
        <h4 id="4-2-Teleport瞬移"   >
          <a href="#4-2-Teleport瞬移" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-Teleport瞬移" class="headerlink" title="4.2 Teleport瞬移"></a>4.2 Teleport瞬移</h4>
      </li>
<li>提供一种干净的方法，让组件的html在父组件界面外的特定标签<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Teleport to=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">&lt;/Teleport&gt;</span><br></pre></td></tr></table></div></figure>

        <h4 id="4-3-Supense不确定"   >
          <a href="#4-3-Supense不确定" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-Supense不确定" class="headerlink" title="4.3 Supense不确定"></a>4.3 Supense不确定</h4>
      </li>
<li>他们允许我们的应用程序在等待异步组件时渲染一些后备内容，可以让我们创建一个平滑的用户体验</li>
<li>骨架屏</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://lovepink527.github.io">姜慧慧</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://lovepink527.github.io/2022/01/11/vue3%E5%88%9D%E4%BD%93%E9%AA%8C/">https://lovepink527.github.io/2022/01/11/vue3%E5%88%9D%E4%BD%93%E9%AA%8C/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://lovepink527.github.io/tags/vue/">vue</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/01/16/TypeScript%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">TypeScript基本使用</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/01/10/vue%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"><span class="paginator-prev__text">vue项目初始化配置</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81vite%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">
          一、vite初始化项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Composition-API-%E5%B8%B8%E7%94%A8%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">
          二、Composition API(常用部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1setup%E5%92%8Cref"><span class="toc-number">2.1.</span> <span class="toc-text">
          2.1setup和ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2reactive%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">
          2.2reactive的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3vue2%E5%92%8Cvue3%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">
          2.3vue2和vue3的响应式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4ref%E5%92%8Creactive"><span class="toc-number">2.4.</span> <span class="toc-text">
          2.4ref和reactive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E8%A7%86"><span class="toc-number">2.5.</span> <span class="toc-text">
          2.5计算属性和监视</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94"><span class="toc-number">2.6.</span> <span class="toc-text">
          2.6声明周期对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1%E4%B8%8E2-0%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BB%84%E5%90%88API"><span class="toc-number">2.6.1.</span> <span class="toc-text">
          2.6.1与2.0的声明周期对应的组合API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-%E6%96%B0%E5%A2%9E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">
          2.6.2 新增钩子函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7hook%E5%87%BD%E6%95%B0%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">2.7.</span> <span class="toc-text">
          2.7hook函数自定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8toRefs"><span class="toc-number">2.8.</span> <span class="toc-text">
          2.8toRefs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Composition-API-%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">
          三、Composition API(其他部分)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-shallowReactive-%E4%B8%8E-shallowRef"><span class="toc-number">3.1.</span> <span class="toc-text">
          3.1 shallowReactive 与 shallowRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-readonly%E5%92%8CshallowReadonly"><span class="toc-number">3.2.</span> <span class="toc-text">
          3.1 readonly和shallowReadonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-toRaw%E5%92%8CmarkRaw"><span class="toc-number">3.3.</span> <span class="toc-text">
          3.2 toRaw和markRaw</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-toRef%E5%92%8Cref"><span class="toc-number">3.4.</span> <span class="toc-text">
          3.3 toRef和ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-customRef"><span class="toc-number">3.5.</span> <span class="toc-text">
          3.4 customRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-provide%E5%92%8Cinject"><span class="toc-number">3.6.</span> <span class="toc-text">
          3.5 provide和inject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%88%A4%E6%96%AD"><span class="toc-number">3.7.</span> <span class="toc-text">
          3.6 响应式判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Composition-API-%E6%96%B0"><span class="toc-number">4.</span> <span class="toc-text">
          四、Composition API(新)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Fragment"><span class="toc-number">4.1.</span> <span class="toc-text">
          4.1 Fragment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-Teleport%E7%9E%AC%E7%A7%BB"><span class="toc-number">4.2.</span> <span class="toc-text">
          4.2 Teleport瞬移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Supense%E4%B8%8D%E7%A1%AE%E5%AE%9A"><span class="toc-number">4.3.</span> <span class="toc-text">
          4.3 Supense不确定</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar1.png" alt="avatar"></div><p class="sidebar-ov-author__text">前端知识学习笔记</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>姜慧慧</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>